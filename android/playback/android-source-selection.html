---
title: 'Android：ソースの選択' 
description: このトピックでは、Android用Brightcove Native Player SDKが、ビデオの再生時にデフォルトのソース選択プロセスをどのように使用するかを学習します。
parent: Playback 
grandparent: Androidの開発
---
 <h1>{{ page.title }}</h1>
<article class="bcls-article">
  <summary>{{ page.description }}</summary>

<section class="bcls-section">
<h2 id="Introduction">はじめに</h2>

<p>Brightcoveのカタログから動画を取得する場合、SDK は再生するソースを決定する必要があります。これは、<a href="/android/reference/javadoc/com/brightcove/player/controller/DefaultSourceSelectionController.html"> defaultSourceSelectionController </a>コンポーネントと<a href="/android/reference/javadoc/com/brightcove/player/controller/ExoPlayerSourceSelectionController.html"> exoPlayerSourceSelectionController </a>コンポーネントに実装されています。</p>
</section>

<section class="bcls-section">
<h2 id="Default_selection_process">デフォルトの選択プロセス</h2>

<p>Android 用 Brightcove Player SDK では、デフォルトのソース選択プロセスが使用されます。簡単にするために、SDK によるBrightcove再生 API および Google の exoPlayer のサポートに重点を置きます。</p>

<p>デフォルトの選択プロセスは次のように定義されます。</p>

<ol class="bcls-tasklist">
	<li>
	<p>Android 6.4 以降の Brightcove ネイティブ SDK では、利用可能な場合、すべてのソースタイプの HTTPS 配信が選択されます。</p>

	<p><a href="/android/reference/javadoc/com/brightcove/player/controller/DefaultSourceSelectionController.html">DefaultSourceSelectionController </a>と<a href="/android/reference/javadoc/com/brightcove/player/controller/ExoPlayerSourceSelectionController.html"> exoPlayerSourceSelectionController </a>の両方が、<code translate="No">deliveryType</code>選択したの HTTPS バージョンを選択しようとします。HTTPS ソースが存在しない場合、選択コントローラは最初に使用可能なソースを選択します。</p>

	<aside class="bcls-aside bcls-aside--information">ビデオにWebVTTキャプション/字幕のHTTPソースとHTTPSソースの両方がある場合、Android用ネイティブSDKはHTTPSバージョンを返さない場合があります。Brightcoveはこの状況を認識しており、将来のリリースで修正される予定です。</aside>
	</li>
	<li>NS <a href="/android/reference/javadoc/com/brightcove/player/view/BrightcoveExoPlayerVideoView.html"> BrightcoveExoPlayerVideoView</a>を持っている最初のソースを探します<code translate="No">deliveryType</code>の<strong>MPEG-DASH</strong>、およびどちらでもないプロファイル<strong>urn：hbbtv</strong>または<strong>urn：dvb</strong>。SDK は、これらの DASH プロファイルのどちらでも再生をサポートしていないため、ソースから除外されます。</li>
	<li>上記が見つからない場合、ソースの選択は最初のソースにフォールバックします。<code translate="No">deliveryType</code>の<strong>HLS</strong>。</li>
	<li>そのようなソースが見つからない場合は、ソースにフォールバックします。<code translate="No">deliveryType</code>の<strong>MP4</strong> 256kBpsに最も近いビットレート。</li>
</ol>

<p>ソースが見つかると、次のように実装が続行されます。</p>

<ol class="bcls-tasklist">
	<li>見つかった場合、選択したソースは<strong> SELECT_SOURCE </strong>イベントに対する応答とともに放出されます。</li>
	<li>デフォルトでは、<a href="/android/reference/javadoc/com/brightcove/player/controller/VideoPlaybackController.html"> VideoPlaybackController</a>を処理します<strong>SELECT_SOURCE</strong>応答、放出することによって<strong>SET_SOURCE</strong>イベント。</li>
	<li><a href="/android/reference/javadoc/com/brightcove/player/display/VideoDisplayComponent.html">VideoDisplayComponent </a>またはサブクラスは、基になるプレーヤー (exoPlayer または MediaPlayer) に URL をロードすることによって、<strong> SET_SOURCE </strong>イベントを処理します。</li>
	<li>再生が開始されると、基になるプレーヤーが HLS コンテンツと DASH コンテンツでビットレートを調整します。HLS では、基になるプレーヤーはマスターマニフェストにリストされている最初のビットレートから始まります。</li>
</ol>

<p>デフォルトのトランスコード設定を使用する場合、最初の HLS ソースは、個々のソース (レンディション) をすべて指すマスター m3u8 プレイリストである必要があります。</p>
</section>

<section class="bcls-section">
<h2 id="Setting_HLS_sources">HLS ソースの設定</h2>

<p>SDK のデフォルトのソース選択ポリシーが呼び出される前に、アプリレベルでソース選択をカスタマイズして、望ましくない配信タイプを除外することができます。これを行うには、Playback API の JSON レスポンスから Video オブジェクトに設定されるソースコレクションを変更します。</p>

<p>この例では、HLS ソースのみを使用します。</p>

<pre class="line-numbers">
<code class="language-java" translate="No">catalog.findVideoByReferenceID(videoReferenceId, new com.brightcove.player.edge.VideoListener() {
	@Override
	public void onVideo(Video video) {
	 sourceSelectionFilter(DeliveryType.HLS, video);
	 brightcoveVideoView.add(video);
	 brightcoveVideoView.start();
	}
});</code></pre>

<p><code translate="No">sourceSelectionFilter()</code>メソッドは次のようになります。</p>

<pre class="line-numbers">
<code class="language-java" translate="No">public static void sourceSelectionFilter(@NonNull DeliveryType deliveryTypeFilter, @NonNull Video video) {
 if (video.getSourceCollections().containsKey(deliveryTypeFilter)) {
   // Only remove the other delivery types if the desired type is in our Source collections
   for (DeliveryType deliveryType : DeliveryType.values()) {
     if (!deliveryType.equals(deliveryTypeFilter)) {
            video.getSourceCollections().remove(deliveryType);
     }
   }
 }
}</code></pre>
</section>
</article>